*
*``````````````````````````````*
* NUM2STR :: NUMBER TO STRING  *
*-                            -*
* CONVERTS A 16-BIT NUMBER TO  *
* ITS STRING EQUIVALENT.       *
*-                            -*
* CLOBBERS:                    *
*                              *
* FLAGS:  ????----  REG: AXYM  *
*-                            -*
* CYCLES: ???                  *
* SIZE:                        *
*-                            -*
* USAGE:                       *
*                              *
*   LDA #>$300 ; DESTINATION   *
*   PHA                        *
*   LDA #<$300                 *
*   PHA                        *
*   LDA #>11111 ; VALUE TO     *
*   PHA         ; CONVERT      *
*   LDA #<11111                *
*   PHA                        *
*   JSR NUM2STR                *
*-                            -*
* ENTRY                        *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
* LO BYTE DESTINATION ADDRESS  *
* HI BYTE DESTINATION ADDRESS  *
* LO BYTE VALUE TO CONVERT     *
* HI BYTE VALUE TO CONVERT     *
*-                            -*
* EXIT                         *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
*                              *
*   Y = COUNTER; TRASH         *
*   X = COUNTER; TRASH         *
*   A = LOW BYTE OF RET ADDR   *
*-                            -*
* ADAPTED FROM LEVANTHAL AND   *
* WINTHROP'S /6502 ASSEMBLY    *
* LANGUAGE ROUTINES/.          *
* AS SUCH, THIS MAY NOT FALL   *
* UNDER THE APACHE 2.0 LICENSE *
* AGREEMENT, SINCE THE BOOK    *
* WAS WRITTEN BEFORE THE       *
* LICENSE!                     *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
NUM2STR
*
** SAVE RETURN ADDRESS
*
         PLA
         STA   RETADR
         PLA
         STA   RETADR+1
*
** GET PARAMETERS
*
         PLA
         STA   :VALSTR
         PLA
         STA   :VALSTR+1
*
         STA   :NGFLAG
         BPL   :GETBP     ; BR IF VAL IS POS
         LDA   #0
         SEC
         SBC   :VALSTR
         STA   :VALSTR
         LDA   #0
         SBC   :VALSTR+1
         STA   :VALSTR+1
*
:GETBP
         PLA
         STA   ADDR1      ; ADDRESS TO STORE STRING
         PLA
         STA   ADDR1+1
         LDA   #0         ; SET BUFFER TO EMPTY
         LDY   #0
         STA   (ADDR1),Y  ; BUFFER(0) = 0
*
** CONVERT VAL TO STRING
*
:CNVERT
*
** VALUE = VALUE DIV 10
** MOD10 = VALUE MOD 10
*
         LDA   #0
         STA   :MOD10
         STA   :MOD10+1
         LDX   #16
         CLC              ; CLEAR CARRY
*
:DVLOOP
         ROL   :VALSTR    ; SHIFT  CARRY INTO DIVBIT 0
         ROL   :VALSTR+1  ; WHICH WILL BE THE QUOTIENT
         ROL   :MOD10     ; + SHIFT DIV AT SAME TIME
         ROL   :MOD10+1
*
** A,Y = DIVIDEND - DIVISOR
*
         SEC
         LDA   :MOD10
         SBC   #10
         TAY              ; SAVE LOWB IN REG Y
         LDA   :MOD10+1
         SBC   #0         ; SUBTRACT CARRY
         BCC   :DECCNT    ; BR IF DEND < DIVISOR
         STY   :MOD10     ; ELSE
         STA   :MOD10+1   ; NXT BIT OF Q IS A ONE AND SET
                          ; DIVIDEND = DEND - DIVISOR
:DECCNT
         DEX
         BNE   :DVLOOP
         ROL   :VALSTR    ; SHIFT IN LAST CARRY FOR Q
         ROL   :VALSTR+1
*
** CONCAT NEXT CHAR
*
:CONCH
         LDA   :MOD10
         CLC
         ADC   #$B0
*
** ADC #'0' ; CONVERT 0..9 TO ASCII 0-9
*
         JSR   :CONCAT
*
** IF VALUE <> 0 THEN CONTINUE
*
         LDA   :VALSTR
         ORA   :VALSTR+1
         BNE   :CNVERT    ; BR IF VALUE != 0
*
:EXIT
         LDA   :NGFLAG
         BPL   :POS       ; BR IF ORIG VAL POS
         LDA   #'-'       ; ELSE
         JSR   :CONCAT    ; PUT A MINUS SIGN IN FRONT
*
:POS
*
** RESTORE RETURN ADDRESS
*
         LDA   RETADR+1
         PHA
         LDA   RETADR
         PHA
*
         RTS              ; RETURN
*
********************************
* CONCAT SUBROUTINE
********************************
*
:CONCAT
         PHA              ; SAVE CHAR ON STACK
*
** MOVE BUFFER RIGHT ONE CHAR
*
         LDY   #0
         LDA   (ADDR1),Y  ; GET CURRENT LENGTH
         TAY
         BEQ   :EXITMR    ; BR IF LENGTH=0
*
:MVELP
         LDA   (ADDR1),Y  ; GET NEXT CHAR
         INY
         STA   (ADDR1),Y  ; STORE IT
         DEY
         DEY
         BNE   :MVELP     ; CONT UNTIL DONE
*
:EXITMR
         PLA              ; GET CHAR BACK FROM STACK
         LDY   #1
         STA   (ADDR1),Y  ; STORE THE CHAR
         LDY   #0
         LDA   (ADDR1),Y  ; GET LENGTH BYTE
         CLC
         ADC   #1         ; INC LENGTH BY ONE
         STA   (ADDR1),Y  ; UPDATE LENGTH
*
         RTS
*
** DATA
*
:NGFLAG  DS    1
:VALSTR  DS    2
:MOD10   DS    2
*
