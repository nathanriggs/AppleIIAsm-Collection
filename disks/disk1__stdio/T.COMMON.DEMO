*
********************************
*                              *
*      -< COMMON DEMO )-       *
*                              *
*       VERSION 00.00.01       *
*                              *
*         03/04/1980           *
*                              *
********************************
*                              *
*       NATHAN D. RIGGS        *
*   NATHAN.RIGGS@OUTLOOK.COM   *
*                              *
********************************
*
** ASSEMBLER DIRECTIVES
*
         CYC   AVE
         EXP   ONLY
         DSK   COMMON.DEMO
*
*``````````````````````````````*
*  TOP INCLUDES (PUTS, MACROS) *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
         PUT   DECS
         USE   COMMON.MAC
*
         PUT   COMMON.HOOKS
*
         ORG   $6000
*
*``````````````````````````````*
*      PROGRAM MAIN BODY       *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
*
*
** BIG LUMPS -- HIGH LEVEL CODE
*
*
** MEMFILL DOES ABOUT WHAT ITS NAME
** IMPLIES: IT FILLS A BLOCK OF MEMORY
** WITH A PARTICULAR CHARACTER. TO SEE
** THIS IN ACTION, HEAD OVER TO THE
** MONITOR BEFORE AND AFTER THIS RUNS
** AND TYPE 300L.
*
** THE SAME AS BELOW CAN BE ACCOMPLISHED
** WITH THE FOLLOWING MACRO:
*
**       _MFIL $300;#10;#0
*
         LDA   #>$300     ; AREA TO FILL; HIGH
         PHA
         LDA   #<$300     ; LOW
         PHA
         LDA   #>10
         PHA
         LDA   #<10
         PHA
         LDA   #0         ; FILL CHARACTER
         PHA
         JSR   MEMFILL
*
** MEMMOVE ALSO DOES WHAT IT SAYS: IT MOVES
** A BLOCK OF MEMORY FROM A SOURCE LOCATION
** TO A DESTINATION LOCATION. WE'LL NOW MOVE
** THOSE ZEROES PLACED BY MEMFILL TO ANOTHER
** LOCATION. AGAIN, YOU'LL ONLY SEE THIS
** CHANGE VIA THE MONITOR (CALL-151).
*
*
** THIS CAN ALSO BE DONE WITH THE MACRO:
*
**       _MMOV $300;$320;#10
*
         LDA   #>$300     ; SRC HIGH
         PHA
         LDA   #<$300     ; SRC LOW
         PHA
         LDA   #>$320     ; DEST HIGH
         PHA
         LDA   #<$320     ; DEST LOW
         PHA
         LDA   #>10       ; # OF BYTES TO MOVE
         PHA
         LDA   #<10       ; LOW BYTE
         PHA
         JSR   MEMMOVE
*
** DELAYMS RUNS THROUGH CYCLES OF THE
** 6502 UNTIL A CERTAIN AMOUNT OF TIME
** HAS PASSED.
*
** IN MACRO FORM:
*
**       _DLAY #250
**       _DLAY #250
**       _DLAY #250
**       _DLAY #250
*
         LDY   #250       ; TIME IN MILLISECONDS
                          ; IS PASSED VIA Y
                          ; 250 = 1/4 SECOND
         JSR   DELAYMS
         LDY   #250
         JSR   DELAYMS
         LDY   #250
         JSR   DELAYMS
         LDY   #250
         JSR   DELAYMS    ; = 1 SECOND DELAY
*
** ZSAVE BACKS UP THE "FREE" AREAS OF
** THE ZERO PAGE TO AN ALTERNATE MEMORY
** LOCATION. THIS IS MOSTLY USEFUL WHEN
** YOU KNOW A ROUTINE USES THE ZERO PAGE,
** BUT YOU WANT TO KEEP THE VALUES CURRENTLY
** STORED THERE AFTER CALLING THE ROUTINE.
*
** IN MACRO FORM:
*
**       _ZSV  $6D00
*
         LDA   #01
         STA   $06
         LDA   #02
         STA   $07
         LDA   #03
         STA   $08
         LDA   #04
         STA   $09
         LDA   #>$6D00
         PHA
         LDA   #<$6D00    ; LOW DEST
         PHA
         JSR   ZSAVE
*
** YOU CAN RESTORE THE ZERO PAGE TO ITS
** PRIOR STATE BY THEN CALLING ZLOAD.
*
** MACRO:
*
**       _ZLD  $6D00
*
         LDA   #>$6D00    ; HIGH; SOURCE
         PHA
         LDA   #<$6D00    ; LOW
         PHA
         JSR ZLOAD
*
*
** LITTLE LUMPS -- MID/LOW LEVEL
*
*
         JMP   REENTRY
*
*``````````````````````````````*
*        BOTTOM INCLUDES       *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
*
** BOTTOM INCLUDES
*
         PUT   COMMON.LIB
*
*
