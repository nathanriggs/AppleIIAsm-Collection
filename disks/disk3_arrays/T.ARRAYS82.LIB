         JMP   ARRAYS82X
*
*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*
*                              *
* ARRAYS82.LIB                 *
*                              *
* AUTHOR:   NATHAN RIGGS       *
* CONTACT:  NATHAN.RIGGS@      *
*           OUTLOOK.COM        *
*                              *
* VERSION:   0.2.0             *
* DATE:      09-DEC-2018       *
* ASSEMBLER: MERLIN 8 PRO      *
* OS:        DOS 3.3           *
* LICENSE:   APACHE 2.0        *
*                              *
* THIS IS A STANDARD LIBRARY   *
* FOR 8BIT, 2 DIMENSIONAL      *
* ARRAY MANIPULATION. ARRAYS   *
* ARE PRECEDED BY LENGTH AND   *
* INDEXING INFORMATION.        *
*                              *
*------------------------------*
*                              *
* LIST OF ROUTINES             *
*                              *
* ADIM82 : DIM 2D, 8BIT ARRAY  *
* AGET82: GET SPECIFIED INDEX  *
*         ELEMENT; PUT RETURN  *
* APUT82: PUT CONTENTS OF ONE  *
*         ADDRESS INTO ARRAY   *
*         AT INDEX X,Y         *
*                              *
*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*
*
*``````````````````````````````*
* ADIM82 :       INIT 2D ARRAY *
*-                            -*
* THIS SIMPLY CREATES A 1D     *
* ARRAY WITH THE DIM OF        *
* [:AXSIZE] BY [:AYSIZE].      *
*-                            -*
* FIRST BYTE OF MEMORY USED    *
* HOLDS LENGTH OF X (ROWS);    *
* SECOND BYTE HOLDS LENGTH OF  *
* Y (COLUMNS); THIRD BYTE      *
* HOLDS LENGTH OF EACH ELEMENT *
*-                            -*
* CLOBBERS:                    *
*                              *
* FLAGS:  ????----  REG: AXYM  *
*-                            -*
* CYCLES: ???                  *
* SIZE:                        *
*-                            -*
* USAGE:                       *
*                              *
*  LDA #>$300 ; ARRAY ADDR     *
*  PHA                         *
*  LDA #<$300                  *
*  PHA                         *
*  LDA #4 ; X DIMENSION BOUND  *
*  PHA                         *
*  LDA #4 ; Y DIMENSION BOUND  *
*  PHA                         *
*  LDA #1 ; ELEMENT BYTESIZE   *
*  PHA                         *
*  JSR DIM82                   *
*-                            -*
* ENTRY                        *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
* ELEMENT SIZE IN BYTES        *
* Y DIMENSION BOUNDARY         *
* X DIMENSION BOUNDARY         *
* ARRAY ADDRESS, LOW BYTE      *
* ARRAY ADDRESS, HIGH BYTE     *
*-                            -*
* EXIT                         *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
*                              *
* .Y = ARRAY ADDRESS LO BYTE   *
* .X = ARRAY ADDRESS HI BYTE   *
* .A = ELEMENT SIZE            *
*                              *
* [RETURN] = TOTAL BYTE SIZE   *
* OF ARRAY.                    *
*                              *
* [RETLEN] = LENGTH IN BYTES   *
* OF THE RETURN VALUE.         *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
ADIM82
*
** SAVE RETURN ADDRESS
*
         PLA
         STA   RETADR
         PLA
         STA   RETADR+1
*
** GET PARAMETERS
*
         PLA
         STA   :MCAND     ; ELEMENT LENGTH
         PLA
         STA   :AYSIZE
         STA   :AYBAK
         PLA
         STA   :AXSIZE
         STA   :AXBAK
         PLA
         STA   ADDR1
         PLA
         STA   ADDR1+1
         LDA   #0
         STA   :MCAND+1
*
** LOOP THROUGH Y, CLEARING MEMORY
** FOR X BYTES TIMES ELEMENT SIZE,
** MOVING TO END OF LAST CLEAR
** UNTIL FINISHED
*
** MULTIPLY X AND Y
*
         LDA   #0
         TAY
         STY   SCRATCH
         BEQ   :ENTLP
*
:DOADD
         CLC
         ADC   :AXSIZE
         TAX
*
         TYA
         ADC   SCRATCH
         TAY
         TXA
*
:LP
         ASL   :AXSIZE
         ROL   SCRATCH
:ENTLP
         LSR   :AYSIZE
         BCS   :DOADD
         BNE   :LP
*
         STX   :MLIER
         STY   :MLIER+1
*
** NOW MULTIPLY BY LENGTH OF ELEMENTS
*
         LDA   #0
         STA   :PROD
         STA   :PROD+1
         STA   :PROD+2
         STA   :PROD+3
         LDX   #$10
:SHIFTR  LSR   :MLIER+1
         ROR   :MLIER
         BCC   :ROTR
         LDA   :PROD+2
         CLC
         ADC   :MCAND
         STA   :PROD+2
         LDA   :PROD+3
         ADC   :MCAND+1
:ROTR
         ROR
         STA   :PROD+3
         ROR   :PROD+2
         ROR   :PROD+1
         ROR   :PROD
         DEX
         BNE   :SHIFTR
*
         CLC
         INC   :PROD      ; INCREASE BY 3
         INC   :PROD
         INC   :PROD
         BCC   :NOCAR
         INC   :PROD+1
:NOCAR
*
** NOW CLEAR MEMORY BLOCKS, WHOLE PAGES FIRST
*
         LDA   #$00       ; FILL VALUE
         LDX   :PROD+1    ; NOTE THAT THIS WON'T
                          ; GO BEYOND A 16BIT VALUE;
                          ; ANYTHING HIGHER THAN
                          ; 16BITS IS MORE THAN
                          ; THERE IS MEMORY IN A
                          ; STANDARD APPLE ][
         BEQ   :PART
         LDY   #0
:FULL
         STA   (ADDR1),Y
         INY
         BNE   :FULL
         INC   ADDR1+1
         DEX
         BNE   :FULL      ; LOOP UNTIL PAGES DONE
*
** NOW DO REMAINING BYTES
*
:PART
         LDX   :PROD
         BEQ   :MFEXIT
         LDY   #0
:PARTLP
         STA   (ADDR1),Y
         INY
         DEX
         BNE   :PARTLP    ; LOOP UNTIL DONE
:MFEXIT
*
** NOW SET SIZES
*
         LDY   #0
         LDA   :AXBAK
         STA   (ADDR1),Y
         INY
         LDA   :AYBAK
         STA   (ADDR1),Y
         INY
         LDA   :MCAND
         STA   (ADDR1),Y
*
** RESTORE RETURN ADDRESS
*
         LDA   RETADR+1
         PHA
         LDA   RETADR
         PHA
*
** RETURN POINTER TO STARTING ADDRESS OF ARRAY
** AND STORE TOTAL BYTE SIZE IN RETURN MEM
*
         LDY   ADDR1
         LDX   ADDR1+1
         LDA   :PROD
         STA   RETURN
         LDA   :PROD+1
         STA   RETURN+1
         LDA   :PROD+2
         STA   RETURN+2
         LDA   :PROD+3
         STA   RETURN+3
         LDA   #4         ; SIZE OF RETURN
         STA   RETLEN
         LDA   :MCAND
*
         RTS
*
** DATA
*
:PROD    DS    4
:AXSIZE  DS    1
:AYSIZE  DS    1
:AXBAK   DS    1
:AYBAK   DS    1
:MLIER   DS    2
:MCAND   DS    2
*
*``````````````````````````````*
* AGET82 :       INIT 2D ARRAY *
*-                            -*
* THIS GETS THE ADDRESS OF AN  *
* ELEMENT AT THE INDEX OF      *
* [:XIDX],[:YIDX].             *
*-                            -*
* CLOBBERS:                    *
*                              *
* FLAGS:  ????----  REG: AXYM  *
*-                            -*
* CYCLES: ???                  *
* SIZE:                        *
*-                            -*
* USAGE:                       *
*                              *
*  LDA #>$300 ; ARRAY ADDR     *
*  PHA                         *
*  LDA #<$300                  *
*  PHA                         *
*  LDA #2 ; X INDEX            *
*  PHA                         *
*  LDA #3 ; Y INDEX            *
*  PHA                         *
*  JSR AGET82                  *
*-                            -*
* ENTRY                        *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
* Y INDEX OF ELEMENT           *
* X INDEX OF ELEMENT           *
* LOW BYTE OF ARRAY ADDRESS    *
* HIGH BYTE OF ARRAY ADDRESS   *
*-                            -*
* EXIT                         *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
*                              *
* .Y = LO BYTE OF ELEM ADDR    *
* .X = HI BYTE OF ELEM ADDR    *
* .A = ELEMENT/RETURN LENGTH   *
*                              *
* [RETURN] = VALUE FOUND AT    *
* SPECIFIED INDEX.             *
*                              *
* [RETLEN] = LENGTH IN BYTES   *
* OF THE RETURN VALUE.         *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
AGET82
*
** SAVE RETURN ADDRESS
*
         PLA
         STA   RETADR
         PLA
         STA   RETADR+1
*
** GET PARAMETERS
*
         PLA
         STA   :YIDX
         PLA
         STA   :XIDX
         PLA
         STA   ADDR1
         PLA
         STA   ADDR1+1
*
         LDY   #2
         LDA   (ADDR1),Y  ; ELEMENT LENGTH
         STA   :MCAND     ; ELEMENT LENGTH
         STA   :ELEN
         LDA   #0
         STA   :MCAND+1
*
** MULTIPLY X AND Y
*
         LDA   #0
         TAY
         STY   SCRATCH
         BEQ   :ENTLP
*
:DOADD
         CLC
         ADC   :XIDX
         TAX
*
         TYA
         ADC   SCRATCH
         TAY
         TXA
*
:LP
         ASL   :XIDX
         ROL   SCRATCH
:ENTLP
         LSR   :YIDX
         BCS   :DOADD
         BNE   :LP
*
         STX   :MLIER
         STY   :MLIER+1
*
** NOW MULTIPLY BY LENGTH OF ELEMENTS
*
         LDA   #0
         STA   :PROD+2
         STA   :PROD+3
         LDX   #$10
:SHIFTR  LSR   :MLIER+1
         ROR   :MLIER
         BCC   :ROTR
         LDA   :PROD+2
         CLC
         ADC   :MCAND
         STA   :PROD+2
         LDA   :PROD+3
         ADC   :MCAND+1
:ROTR
         ROR
         STA   :PROD+3
         ROR   :PROD+2
         ROR   :PROD+1
         ROR   :PROD
         DEX
         BNE   :SHIFTR
*
         CLC
         INC   :PROD      ; INCREASE BY 3
         INC   :PROD
         INC   :PROD
         BCC   :NOCAR
         INC   :PROD+1
:NOCAR
*
** NOW ADD BASE ADDRESS OF ARRAY TO GET
** THE ADDRESS OF THE INDEX VALUE
*
         CLC
         LDA   :PROD
         ADC   ADDR1
         STA   :PROD
         LDA   :PROD+1
         ADC   ADDR1+1
         STA   :PROD+1
*
** RETURN ADDRESS IN Y(LOW) AND X(HIGH)
*
         LDY   :PROD
         LDX   :PROD+1
         STY   ADDR1
         STX   ADDR1+1
         LDY   #0
:RLP
         LDA   (ADDR1),Y
         STA   RETURN,Y
         INY
         CPY   :ELEN
         BNE   :RLP
         LDA   :ELEN
         STA   RETLEN
*
** RESTORE RETURN ADDRESS
*
         LDA   RETADR+1
         PHA
         LDA   RETADR
         PHA
*
         LDA   RETLEN
         LDY   ADDR1
         LDX   ADDR1+1
         RTS
*
** DATA
*
:XIDX    DS    2
:YIDX    DS    2
:PROD    DS    4
:MLIER   DS    2
:MCAND   DS    2
:ELEN    DS    1
*
*``````````````````````````````*
* APUT82 :  PUT DATA INTO ELEM *
*-                            -*
* THIS PUTS DATA FROM ONE ADDR *
* INTO THE ADDRESS OF AN ARRAY *
* WITH THE INDEX OF [:XIDX],   *
* [:YIDX].                     *
*-                            -*
* CLOBBERS:                    *
*                              *
* FLAGS:  ????----  REG: AXYM  *
*-                            -*
* CYCLES: ???                  *
* SIZE:                        *
*-                            -*
* USAGE:                       *
*                              *
*  LDA #>$300 ; SOURCE DATA    *
*  PHA                         *
*  LDA #<$300                  *
*  PHA                         *
*  LDA #>$3A0 ; DEST ARRAY     *
*  PHA                         *
*  LDA #<$3A0                  *
*  PHA                         *
*  LDA #2 ; ELEM X INDEX       *
*  PHA                         *
*  LDA #3 ; ELEM Y INDEX       *
*  PHA                         *
*  JSR APUT82                  *
*-                            -*
* ENTRY                        *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
* ELEMENT Y INDEX              *
* ELEMENT X INDEX              *
* LOW BYTE OF DESTINATION ADDR *
* HI BYTE OF DESTINATION ADDR  *
* LO BYTE OF SOURCE ADDRESS    *
* HI BYTE OF SOURCE ADDRESS    *
*-                            -*
* EXIT                         *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
*                              *
* .Y = LOBYTE ELEMENT ADDRESS  *
* .X = HIBYTE ELEMENT ADDRESS  *
* .A = ELEMENT BYTE LENGTH     *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
APUT82
*
** SAVE RETURN ADDRESS
*
         PLA
         STA   :RETADR    ; LOCAL BECAUSE OF
         PLA              ; CALLING AGET82
         STA   :RETADR+1
*
** GET PARAMETERS
*
         PLA
         STA   :YIDX      ; Y INDEX
         PLA
         STA   :XIDX      ; X INDEX
         PLA
         STA   ADDR4      ; ADDRESS OF ARRAY
         PLA
         STA   ADDR4+1
         PLA
         STA   ADDR3      ; ADDRESS OF DATA
         PLA              ; TO BE COPIED
         STA   ADDR3+1
*
** NOW RUN AGET82 TO GET PROPER ADDRESS
*
         LDA   ADDR4+1    ; ARRAY ADDRESS
         PHA
         LDA   ADDR4
         PHA
         LDA   :XIDX      ; X INDEX
         PHA
         LDA   :YIDX      ; Y INDEX
         PHA
         JSR   AGET82
         STY   ADDR2      ; STORE ADDRESS OF INDEX
         STX   ADDR2+1    ; IN ZERO PAGE
*
** GET ARRAY ELEMENT SIZE
*
         LDY   #2
         LDA   (ADDR4),Y
         STA   :ESIZE
         LDY   #0
*
** COPY FROM SRC ADDR TO DEST ADDR
*
:CLP
         LDA   (ADDR3),Y
         STA   (ADDR2),Y
         INY
         CPY   :ESIZE
         BNE   :CLP
*
** RESTORE RETURN ADDRESS
*
         LDA   :RETADR+1
         PHA
         LDA   :RETADR
         PHA
*
** RETURN ELEMENT ADDRESS AND SIZE
*
         LDX   ADDR2+1
         LDY   ADDR2
         LDA   :ESIZE
*
         RTS
*
** DATA
*
:RETADR  DS    2
:ESIZE   DS    1
:XIDX    DS    1
:YIDX    DS    1
*
ARRAYS82X
*
