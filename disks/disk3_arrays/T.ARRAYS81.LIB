         JMP   ARRAYS81X
*
*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*
*                              *
* ARRAYS81.LIB                 *
*                              *
* AUTHOR:  NATHAN RIGGS        *
* CONTACT: NATHAN.RIGGS@       *
*          OUTLOOK.COM         *
*                              *
* VERSION: 0.1.2               *
* DATE:    30-OCT-2018         *
* ASSEMBLER: MERLIN 8 PRO      *
*                              *
* LICENSE: APACHE 2.0, WHERE   *
*  APPLICABLE. CODE INSPIRED   *
*  BY THE WORKS OF OTHERS MAY  *
*  FALL UNDER A DIFFERENT      *
*  LICENSE (NOTED IN ROUTINE). *
*                              *
* THIS IS A STANDARD LIBRARY   *
* FOR 1-DIMENSIONAL 8-BIT      *
* ARRAY MANIPUALTION. ARRAYS   *
* ARE PRECEDED BY LENGTH AND   *
* INDEXING INFORMATION.        *
*                              *
*------------------------------*
*                              *
* LIST OF ROUTINES             *
*                              *
* DIM81 : DIM 8BIT,1D ARRAY    *
* AGET81 : GET ADDR OF ELEMENT *
* APUT81 : COPY DATA FROM MEM  *
*          INTO ELEMENT AT     *
*          SPECIFIED LOCATION  *
*                              *
*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*
*
*``````````````````````````````*
* DIM81D :: INIT 1D ARRAY      *
*-                            -*
* CREATES AN ARRAY OF LENGTH   *
* :ASIZE WITH ELEMENTS OF      *
* LENGTH :ESIZE AT MEMORY      *
* LOCATION POINTED TO BY       *
* :ALOC. RETURNS ARRAY START   *
* LOCATION IF SUCCESSFUL IN A, *
* OR 0FF IF UNSUCCESSFUL.      *
*-                            -*
* FIRST BYTE OF MEMORY USED    *
* HOLDS LENGTH OF ARRAY;       *
* SECOND BYTE HOLDS LENGTH OF  *
*-                            -*
* CLOBBERS:                    *
*                              *
* FLAGS:  ????----  REG: AXYM  *
*-                            -*
* CYCLES: ???                  *
* SIZE:                        *
*-                            -*
* USAGE:                       *
*                              *
*       LDA  #>$300 ; ARRAYLOC *
*       PHA                    *
*       LDA  #<$300            *
*       PHA                    *
*       LDA  #10 ; ARRAY SIZE  *
*       PHA                    *
*       LDA  #2 ; ELEMENT SIZE *
*       PHA                    *
*       JSR  DIM81             *
*-                            -*
* ENTRY                        *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
* ELEMENT SIZE                 *
* ARRAY SIZE                   *
* LOW BYTE OF ARRAY ADDRESS    *
* HIGH BYTE OF ARRAY ADDRESS   *
*-                            -*
* EXIT                         *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
*                              *
*   Y = LO BYTE OF ARRAY ADDR  *
*   X = HI BYTE OF ARRAY ADDR  *
*   A = TRASH                  *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
DIM81
*
** FIRST, CLEAR BLOCK OF MEM TO BE USED
**  THEN MUL ASIZE BY ESIZE, AND ADD 2 TO
** GET TOTAL MEMORY USED BY ARRAY
*
** SAVE RETURN ADDRESS
*
         PLA
         STA   RETADR
         PLA
         STA   RETADR+1
*
** GET PARAMETERS
*
         PLA
         STA   :ESIZE     ; ELEMENT SIZE
         STA   :ESZBAK
         PLA
         STA   :ASIZE     ; ARRAY SIZE
         STA   :ASZBAK
         PLA
         STA   ADDR1
         PLA
         STA   ADDR1+1
         LDY   #0
         LDX   #0
         LDA   #0
         STY   SCRATCH
         BEQ   :ENTLP
*
** MULTIPLY ASIZE AND ESIZE TO GET TOTAL SIZE
** OF MEMORY TO CLEAR AND USE
*
:DOADD
         CLC
         ADC   :ASIZE
         TAX
*
         TYA
         ADC   SCRATCH
         TAY
         TXA
*
:LP
         ASL   :ASIZE
         ROL   SCRATCH
:ENTLP
         LSR   :ESIZE
         BCS   :DOADD
         BNE   :LP
*
         CLC
         INX
         INX              ; INCREASE BY TWO
                          ; TO MAKE ROOM FOR SIZES
         BCC   :NOINY     ; IF X ROLLS OVER, INC Y
         INY
:NOINY
         STX   :MSIZE     ; LOW BYTE
         STY   :MSIZE+1   ; HIGH BYTE
*
** NOW CLEAR MEMORY BLOCKS
*
** FILL WHOLE PAGES FIRST
*
         LDA   #0         ; FILL VALUE
         LDX   :MSIZE+1
         BEQ   :PART      ; IF NO WHOLE PAGES, JUST PART
         LDY   #0
:FULL
         STA   (ADDR1),Y
         INY              ; NEXT BYTE
         BNE   :FULL      ; LOOP UNTIL PAGE DONE
         INC   ADDR1+1    ; GO TO NEXT PAGE
         DEX
         BNE   :FULL      ; LOOP IF PAGES LEFT
*
** NOW DO REMAINING PARTIAL PAGES
*
:PART
         LDX   :MSIZE     ; PARTIAL PAGE BYTES
         BEQ   :MFEXIT    ; EXIT IF = 0
         LDY   #0
:PARTLP
         STA   (ADDR1),Y  ; STORE VAL
         INY              ; INC INDEX
         DEX              ; DEC COUNTER
         BNE   :PARTLP    ; LOOP UNTIL DONE
:MFEXIT
*
** MEMORY FILL IS DONE
*
** THEN, SET SIZES
*
         LDY   #0
         LDA   :ASZBAK
         STA   (ADDR1),Y
         INY
         LDA   :ESZBAK
         STA   (ADDR1),Y
*
** RESTORE RETURN ADDRESS
*
         LDA   RETADR+1
         PHA
         LDA   RETADR
         PHA
*
** RETURN POINTER TO STARTING ADDR OF ARRAY
*
         LDY   ADDR1      ; LOW
         LDX   ADDR1+1    ; HIGH
*
         RTS
*
** DATA
*
:MSIZE   DS    2
:ASIZE   DS    1
:ESIZE   DS    1
:ASZBAK  DS    1
:ESZBAK  DS    1
*
*``````````````````````````````*
* AGET81 :: GET ARRAY ELEMENT  *
*           ADDRESS            *
*-                            -*
* GETS THE ADDRESS LOCATION OF *
* AN ELEMENT IN THE SPECIFIED  *
* ARRAY AT THE SPECIFIED INDEX *
*-                            -*
* CLOBBERS:                    *
*                              *
* FLAGS:  ????----  REG: AXYM  *
*-                            -*
* CYCLES: ???                  *
* SIZE:                        *
*-                            -*
* USAGE:                       *
*                              *
*        LDA #>$300 ;HI ARADDR *
*        PHA                   *
*        LDA #<$300 ; LOW      *
*        PHA                   *
*        LDA #5 ; INDEX        *
*        PHA                   *
*        JSR AGET81            *
*-                            -*
* ENTRY                        *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
* INDEX OF ELEMENT TO GET      *
* ADDRESS OF ARRAY LO BYTE     *
* ADDRESS OF ARRAY HI BYTE     *
*-                            -*
* EXIT                         *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
*                              *
*   Y = LOBYTE OF ELEMENT ADDR *
*   X = HIBYTE OF ELEMENT ADDR *
*   A = TRASH                  *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
AGET81
*
** SAVE RETURN ADDRESS
*
         PLA
         STA   RETADR
         PLA
         STA   RETADR+1
*
** GET PARAMETERS
*
         PLA
         STA   :IDX
         PLA
         STA   ADDR1
         PLA
         STA   ADDR1+1
*
** GET ELEMENT SIZE
*
         LDY   #1         ; ELEMENT SIZE LOC
         LDA   (ADDR1),Y
         STA   :ESIZE
*
*
** FIRST, MUL INDEX BY ELEMENT SIZE,
** THEN ADD TWO TO GET THE PROPER ADDRESS.
*
         LDY   #0
         LDA   #0
         TAY
         STY   SCRATCH
         BEQ   :ENTLP
*
:DOADD
         CLC
         ADC   :IDX
         TAX
         TYA
         ADC   SCRATCH
         TAY
         TXA
:LP
         ASL   :IDX
         ROL   SCRATCH
:ENTLP
         LSR   :ESIZE
         BCS   :DOADD
         BNE   :LP
*
** ARRAY INDEX STORED IN X (LOW) AND Y (HIGH)
*
         STX   :IDX
         STY   :IDX+1
*
** ADD 2 TO INDEX
*
         CLC
         LDA   #2
         ADC   :IDX
         STA   :RES
         LDA   #0
         ADC   :IDX+1
         STA   :RES+1
*
** NOW ADD THAT TO BASE ARRAY ADDRESS
** TO GET ADDRESS OF INDEX VALUE
*
         CLC
         LDA   :RES
         ADC   ADDR1      ; LOW OF ARRAY ADDRESS
         STA   :RES
         LDA   :RES+1
         ADC   ADDR1+1
         STA   :RES+1
*
** ADDRESS TO ARRAY ELEMENT IS STORED
** IN Y (LOW BYTE), X (HIGH BYTE)
*
         LDY   :RES
         LDX   :RES+1
*
** RESTORE RETURN ADDRESS
*
         LDA   RETADR+1
         PHA
         LDA   RETADR
         PHA
*
         RTS
*
** DATA
*
:RES     DS    2
:IDX     DS    2
:ESIZE   DS    1
*
*``````````````````````````````*
* APUT81 :: PUT TO ARR ELEMNT  *
*-                            -*
* COPIES FROM SOURCE LOCATION  *
* AND PUTS IT IN MEMLOC FOR    *
* DESIRED ELEMENT. DIRECT      *
* PUTTING OF ELEMENT DATA      *
* CAN BE DONE VIA SIMPLE       *
* LDA/STA OPERATIONS.          *
*-                            -*
* NOTE THAT THIS DOES NOT      *
* CHECK FOR OUT OF BOUNDS      *
* SO THAT CYCLES ARE NOT       *
* WASTED.                      *
*-                            -*
* CLOBBERS:                    *
*                              *
* FLAGS:  ????----  REG: AXYM  *
*-                            -*
* CYCLES: ???                  *
* SIZE:                        *
*-                            -*
* USAGE:                       *
*                              *
*        LDA #>$300 ; SRC ADDR *
*        PHA                   *
*        LDA #<$300            *
*        PHA                   *
*        LDA #>$300 ;DEST ADDR *
*        PHA                   *
*        STA #<$300            *
*        PHA                   *
*        LDA #5 ; INDEX        *
*        PHA                   *
*-                            -*
* ENTRY                        *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
* INDEX OF PUT ELEMENT         *
* LOW BYTE OF DESTINATION ADDR *
* HI BYTE OF DESTINATION ADDR  *
* LO BYTE OF SOURCE ADDRESS    *
* HI BYTE OF SOURCE ADDRESS    *
*-                            -*
* EXIT                         *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
*                              *
*   Y = LOBYTE OF ELEMENT ADDR *
*   X = HIBYTE OF ELEMENT ADDR *
*   A = BYTE LENGTH OF ELEMENT *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
APUT81
*
** SAVE RETURN ADDRESS
*
         PLA
         STA   :RETADR    ; LOCAL RETURN ADDRESS STORAGE
         PLA              ; BECAUSE OF CALLING AGET81
         STA   :RETADR+1
*
** GET PARAMETERS
*
         PLA
         STA   :AIDX
         PLA
         STA   ADDR4      ; ARRAY ADDRESS; USES ADDR4
                          ; BECAUSE CALL TO AGET81 USES
                          ; ADDR1
         PLA
         STA   ADDR4+1
         PLA
         STA   ADDR3      ; ADDRESS OF DATA TO BE
                          ; COPIED TO ELEMENT
         PLA
         STA   ADDR3+1
*
         LDA   ADDR4+1
         PHA
         LDA   ADDR4
         PHA
         LDA   :AIDX
         PHA
         JSR   AGET81     ; GET MEMORY POS OF ELEM
         STY   ADDR2
         STX   ADDR2+1
*
** GET ARRAY'S ELEMENT SIZE
*
         LDY   #1
         LDA   (ADDR4),Y
         STA   :ESIZE
         LDY   #0
*
** COPY FROM ADDR1 TO ADDR2
*
:LP
         LDA   (ADDR3),Y
         STA   (ADDR2),Y
         INY
         CPY   :ESIZE
         BNE   :LP
*
** RESTORE RETURN ADDRESS
*
         LDA   :RETADR+1
         PHA
         LDA   :RETADR
         PHA
*
** RETURN ELEMENT ADDRESS AND SIZE
** IN REGISTERS
*
         LDX   ADDR2+1
         LDY   ADDR2
         LDA   :ESIZE
*
         RTS
*
** DATA
*
:RETADR  DS    2
:ESIZE   DS    1
:ASIZE   DS    1
:AIDX    DS    1
*
ARRAYS81X
*
