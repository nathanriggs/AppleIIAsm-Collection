*
*``````````````````````````````*
* RANDB :: RANDOM BYTE         *
*-                            -*
* RETURNS A RANDOM BYTE VALUE  *
* BETWEEN THE HIGH AND LOW     *
* BOUNDS PASSED TO ROUTINE.    *
*-                            -*
* CLOBBERS:                    *
*                              *
* FLAGS:  ????----  REG: AXYM  *
*-                            -*
* CYCLES: ???                  *
* SIZE:                        *
*-                            -*
* USAGE:                       *
*                              *
*        LDA #1 ;  LOW BOUND   *
*        PHA                   *
*        LDA #100 ; HIGH       *
*        PHA                   *
*        JSR RANDB             *
*-                            -*
* ENTRY                        *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
*-                            -*
* EXIT                         *
*                              *
* TOP OF STACK                 *
*                              *
* LOW BYTE OF RETURN ADDRESS   *
* HI BYTE OF RETURN ADDRESS    *
*                              *
*   Y = COUNTER; TRASH         *
*   X = COUNTER; TRASH         *
*   A = LOW BYTE OF RET ADDR   *
*-                            -*
* *** NOTE: I DON'T LIKE THAT  *
* THIS HAS TO CALL UDIV16, AND *
* THUS CANNOT BE INCLUDED ON   *
* ITS OWN. IN FUTURE, HANDLE   *
* DIVISION WITHIN ROUTINE,     *
* ESPECIALLY SINCE IT IS 8BIT. *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
RANDB
*
** GET RETURN ADDRESS
*
         PLA
         STA   :RETADR
         PLA
         STA   :RETADR+1
*
** GET PARAMETERS
*
         PLA
         STA   :RHB       ; HIGH BOUND
         PLA
         STA   :RLB       ; LOW BOUND
*
** FORMULA: F = L + (R-((R\(H-L))*(H-L)
*
         LDA   :RHB
         CLC
         ADC   #2         ; NO IDEA WHY I NEED
                          ; THIS BUT I DO
         STA   :RHB
         LDA   :RHB       ;LOAD IN HIGH RANGE
         SEC
         SBC   :RLB       ;SUBTRACT LOW RANGE
         STA   :RHL       ;STORE HIGH - LOW HERE
         JSR   RND8       ; GET NUM BETWEEN 0..255
         STA   :R         ; RANDOM 0,,255
*
** R\(H-L)
*
         LDX   #0         ; STORE 0 FOR HIGH BYTE
         STX   :R+1       ; 0 HIGH BYTE
         STX   :RHL+1     ; 0 HIGH BYTE
         LDA   :R+1
         PHA
         LDA   :R
         PHA
         LDA   :RHL+1     ; LOAD (H-L) BACK INTO A
         PHA
         LDA   :RHL
         PHA
         JSR   UDIV16     ; DIV (H-L) BY __R
         PLA
         STA   :QUOT
         PLA
         STA   :QUOT+1
*
** R-(R\(H-L)
*
         LDA   :R         ; LOAD RND BACK INTO A
         SEC
         SBC   :QUOT      ; SUBTRACT (R/(H-L) FROM RND8
         STA   :QUOT      ; STORE TEMP
*
** (R-(R\(H-L))*(H-L)
*
         LDA   #0         ; ZERO HIGH BYTE
         STA   :QUOT+1    ; 0 HIGH BYTE
         LDA   :RHL+1     ; LOAD (H-L)
         PHA
         LDA   :RHL
         PHA
         LDA   :QUOT+1
         PHA
         LDA   :QUOT
         PHA
         JSR   MUL16      ; MUL (H-L) * __R - (H-L)
         PLA
         STA   :RESULT
         PLA
         STA   :RESULT+1
*
** L + EVERYTHING ELSE
*
         CLC
         ADC   :RLB       ;ADD LOW BYTE TO ALL ELSE
:FINISH
         STA   :RESULT    ; STORE IN RESULT
         LDX   :RESULT+1  ; HIGH BYTE; FOR
                          ; DEBUGGING PURPOSES
*
** RESTORE RETURN ADDRESS
*
         LDA   :RETADR+1
         PHA
         LDA   :RETADR
         PHA
*
         LDA   :RESULT    ; RETURN # IN A
         RTS
*
** DATA
*
:R       DS    2
:RETADR  DS    2
:RESULT  DS    2
:RHB     DS    2
:RLB     DS    2
:RHL     DS    2
:QUOT    DS    2
