********************************
*                              *
* MAZE GENERATOR               *
*                              *
********************************
*
** ASSEMBLER DIRECTIVES
*
         CYC   AVE
         EXP   OFF
         DSK   MAKEMAZE
         TR    ON
         OBJ   $BFE0
         ORG   $6000
*
         PUT   REQUIRED.VARS
         USE   REQUIRED.MAC.MIN
         USE   ARRAYS.MAC.MIN
         USE   MATH.MAC.MIN
         USE   STDIO.MAC.MIN
         PUT   REQUIRED.HOOKS.MIN
         PUT   STDIO.HOOKS
         PUT   MATH.HOOKS
         PUT   ARRAYS.HOOKS
*
********************************
*                              *
* CONSTANT DECLARATIONS        *
*                              *
********************************
*
BAS      EQU   $2000      ; BASE ADDRESS FOR ARRAYS
*
** NOTE THAT XLEN AND YLEN CANNOT EXCEED 13, AS THIS
** WOULD MAKE THE ARRAY SIZES >256, WHICH ISN'T
** WHAT 8-BIT ARRAYS ARE PREPARED TO HANDLE.
*
** THE NEXT UPDATE WILL UTILIZE 16-BIT ARRAYS
** TO ADDRESS THIS PROBLEM.
*
XLEN     KBD   "ENTER MAZE SIZE (<14)"
YLEN     EQU   XLEN       ; CURRENT ALGO ONLY DOES SQUARE
XMAX     EQU   XLEN+2     ; ADD EXTRA COLUMN
YMAX     EQU   YLEN+2     ; ADD EXTRA ROW
XNUM     EQU   2*XLEN+2
ASZ      EQU   XMAX*YMAX+4 ; ARRAY SIZE+INFO BYTES
XSTAKS   EQU   ASZ        ; COLUMN STACK SIZE; X * Y + 1
YSTAKS   EQU   ASZ        ; ROW STACK SIZE; X * Y + 1
*
SOUTHW   EQU   BAS        ; SOUTH WALLS ARRAY
WESTW    EQU   ASZ+BAS    ; WEST WALLS ARRAY
VISITED  EQU   2*ASZ+BAS  ; CELLS VISITED
XSTACK   EQU   3*ASZ+BAS  ; STACK FOR COLUMNS
YSTACK   EQU   4*ASZ+BAS  ; STACK FOR ROWS
*
********************************
*                              *
* MAIN PROGRAM LOOP            *
*                              *
********************************
*
INIT
*
*LDA #0
*STA ERRCTRL ; TURN OFF ERRORS
         JSR   HOME
         PRN   "INITIALIZING...",8D
*
         JSR   :SETVARS
         JSR   :OUTWALLS
*
** GET RANDOM STARTING POINT
*
         RNDB #2;#XLEN
         STA   XX
         RNDB #2;#YLEN
         STA   YY
*
         JMP   BUILD
*
********************************
*
:SETVARS
*
** DIM ARRAYS AND FILL
*
         DIM82 SOUTHW;#XMAX;#YMAX;#1;#1
         DIM82 WESTW;#XMAX;#YMAX;#1;#1
         DIM82 VISITED;#XMAX;#YMAX;#1;#0
         DIM81 XSTACK;#XSTAKS;#1;#0
         DIM81 YSTACK;#YSTAKS;#1;#0
*
** NOW ASSIGN VARIABLE VALUES
*
         LDA   #0
         STA   SPTR
         STA   V0
         LDA   #1
         STA   V1
         RTS
*
********************************
*
:OUTWALLS
*
** MAKE COLUMN MIN AND MAX TO BE ALL
** WALL (CODE: 1).
*
         LDA   #0         ; SO X,Y WILL INC TO 1
         STA   XX
         STA   YY
*
:COLEDGE
         INC   XX
         PUT82 V1;VISITED;XX;#1
         PUT82 V1;VISITED;XX;#YMAX
         LDA   XX
         CMP   #XMAX
         BNE   :COLEDGE
*
** MAKE MIN AND MAX ROWS TO BE ALL WALL
*
:ROWEDGE
         INC   YY
         PUT82 V1;VISITED;#1;YY
         PUT82 V1;VISITED;#XMAX;YY
         LDA   YY
         CMP   #YMAX
         BNE   :ROWEDGE
         RTS
*
********************************
*                              *
*   BUILD THE MAZE             *
*                              *
********************************
*
BUILD
*
         PRN   "BUILDING MAZE...",8D8D
*
********************************
*
STAKPUSH
*
         INC   SPTR
         PUT81 XX;XSTACK;SPTR ; PUT COL ON STACK
         PUT81 YY;YSTACK;SPTR ; PUT ROW ON STACK
         PUT82 V1;VISITED;XX;YY ; MARK BLOCK AS VISITED
*
********************************
*
CHECKALL
*
** CHECKS ALL ADJACENT BLOCKS FOR A WALL. IF
** COMPLETELY SURROUNDED, POP THE STACK AND
** AND START OVER UNTIL.
*
         LDA   YY         ; STORE VALUES FOR
         STA   YP1        ; CURRENT ROW MINUS ONE
         STA   YM1        ; AND CURRENT ROW PLUS
         LDA   XX         ; ONE, THEN DO THE SAME
         STA   XP1        ; FOR COLUMNS
         STA   XM1
*
         INC   YP1
         INC   XP1
         DEC   XM1
         DEC   YM1
*
:_IF1                     ; IF VISITED(XX,Y+1) == 1
         GET82 VISITED;XX;YP1
         LDA   RETURN
         CMP   #1
         BEQ   :_IF2      ; IF CELL BELOW IS A WALL
                          ; CONTINUE TESTING OTHER
                          ; ADJACENT CELLS
         JMP   DOMOVE     ; OTHERWISE, EXIT CONDITIONAL
:_IF2                     ; AND VISITED(X+1,Y) == 1
*
         GET82 VISITED;XP1;YY
         LDA   RETURN
         CMP   #1         ; TEST RIGHT CELL
         BEQ   :_IF3
         JMP   DOMOVE
*
:_IF3                     ; AND IF VISITED(X,Y-1) == 1
         LDA   YM1
         CMP   #0         ; TEST FOR Y=0 TO OVOID
         BNE   :IF3C      ; OUT OF BOUNDS ERROR
         JMP   :_IF4
:IF3C
         GET82 VISITED;XX;YM1
         LDA   RETURN
         CMP   #1         ; TEST CELL ABOVE
         BEQ   :_IF4
         JMP   DOMOVE
*
:_IF4                     ; AND IF VISITED(X-1,Y) == 1
         GET82 VISITED;XM1;YY
         LDA   RETURN
         CMP   #1         ; THEN POP STACKS UNTIL DONE
         BEQ   :POP
*
         JMP   DOMOVE     ; OTHERWISE, EXIT ROUTINE
*
********************************
*
:POP
*
         GET81 XSTACK;SPTR
         LDA   RETURN
         STA   XX
         GET81 YSTACK;SPTR
         LDA   RETURN
         STA   YY
         DEC   SPTR       ; POP
         LDA   SPTR
         CMP   #1         ; IF STILL MORE ON STACK
         BCS   :DOREPEAT
         JMP   DISPMAZE   ; OTHERWISE, FINISHED!
*
:DOREPEAT
         JMP   CHECKALL
*
********************************
*
DOMOVE
*
** MOVE IN A RANDOM DIRECTION
*
         JSR   RAND8
         CMP   #64        ; IF RND < 64
         BCC   :MVDOWN
         CMP   #128       ; ELSE IF RND < 128
         BCC   :MVRIGHT
         CMP   #192       ; ELSE IF RND < 192
         BCC   :MVUP
         JMP   :MVLEFT    ; ELSE RND IS > 191
*
:MVDOWN
         GET82 VISITED;XX;YP1
         LDA   RETURN
         CMP   #0         ; IF NOT A WALL
         BEQ   :DOWNGO
         JMP   DOMOVE
:DOWNGO                   ; THEN MOVE THERE
         PUT82 V0;SOUTHW;XX;YY
         INC   YY
         JMP   STAKPUSH
:MVRIGHT
         GET82 VISITED;XP1;YY
         LDA   RETURN
         CMP   #0
         BEQ   :RIGHTGO
         JMP   DOMOVE
:RIGHTGO
         PUT82 V0;WESTW;XP1;YY
         INC   XX
         JMP   STAKPUSH
*
:MVUP
         LDA   YM1
         CMP   #0
         BEQ   :UPNO
         GET82 VISITED;XX;YM1
         LDA   RETURN
         CMP   #0
         BEQ   :UPGO
:UPNO
         JMP   DOMOVE
:UPGO
         PUT82 V0;SOUTHW;XX;YM1
         DEC   YY
         JMP   STAKPUSH
*
:MVLEFT
         GET82 VISITED;XM1;YY
         LDA   RETURN
         CMP   #0
         BEQ   :LEFTGO
         JMP   DOMOVE
:LEFTGO
         PUT82 V0;WESTW;XX;YY
         DEC   XX
         JMP   STAKPUSH
*
********************************
*                              *
* DISPLAY THE MAZE             *
*                              *
********************************
*
DISPMAZE
*
** SEND MAZE TO DISPLAY OUTPUT, FORMATTED
*
         PRN   "PRINTING...",8D
         PRN   " ",8D
         LDA   #1
         STA   XX
:XLOOP
         INC   XX
         PRN   "X"
         LDA   XX
         CMP   #XNUM
         BNE   :XLOOP
         PRN   " ",8D
*
         LDA   #2
         STA   XX
         STA   YY
WLP
*
** IF WESTW(X,Y) == 0
*
         GET82 WESTW;XX;YY
         LDA   RETURN
         CMP   #0
         BEQ   NOWALLW    ; THEN PRINT ...
YESWALLW                  ; ELSE PRINT X..
         PRN   "X "
         JMP   CONTWLP
NOWALLW
         PRN   "  "
*
CONTWLP
         INC   XX
         LDA   XX
         CMP   #XMAX
         BEQ   :ENDWLP
         JMP   WLP
*
:ENDWLP
         PRN   "X",8D ; NEXT LINE
*
         LDA   #2
         STA   XX         ; RECYCLING
*
** IF SOUTHW(X,Y) == 0
*
SLP
         GET82 SOUTHW;XX;YY
         LDA   RETURN
         CMP   #0
         BEQ   NOSOUTH    ; THEN PRINT X..
YSOUTH                    ; ELSE PRINT XXX
         PRN   "XX"
         JMP   CONTSLP
NOSOUTH
         PRN   "X "
CONTSLP
         INC   XX
         LDA   XX
         CMP   #XMAX
         BEQ   :ENDSLP
         JMP   SLP
:ENDSLP
*
         PRN   "X",8D
*
         LDA   #2
         STA   XX
         INC   YY
         LDA   YY
         CMP   #YMAX
         BEQ   DISPEXIT
         JMP   WLP
*
DISPEXIT
*
         _WAIT
         JMP   REENTRY
*
********************************
*                              *
* VARIABLES                    *
*                              *
********************************
*
V0       DS    1          ; USED BECAUSE OF CURRENT
V1       DS    1          ; ARRAY DIM LIMITATIONS
*
XX       DS    1          ; CURRENT COLUMN
YY       DS    1          ; CURRENT ROW
SPTR     DS    1          ; ARRAY STACK POINTER
XP1      DS    1          ; X PLUS ONE
XM1      DS    1          ; X MINUS ONE
YP1      DS    1          ; Y PLUS ONE
YM1      DS    1          ; Y MINUS ONE
*
********************************
*                              *
*  LOW-LEVEL ROUTINES          *
*                              *
********************************
*
         PUT   REQUIRED.LIB.MIN
*
** INDIVIDUAL SUBROUTINES
*
** ARRAYS
*
         PUT   ADIM81.SUB.MIN
         PUT   ADIM82.SUB.MIN
         PUT   AGET81.SUB.MIN
         PUT   AGET82.SUB.MIN
         PUT   APUT81.SUB.MIN
         PUT   APUT82.SUB.MIN
*
** MATH
*
         PUT   RAND8.SUB.MIN
         PUT   RANDB.SUB.MIN
*
** STDIO
*
         PUT   DPRINT.SUB.MIN
         PUT   XPRINT.SUB.MIN
*
