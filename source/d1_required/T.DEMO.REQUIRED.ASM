*
*``````````````````````````````*
* DEMO.REQUIRED                *
*                              *
* THIS IS A DEMO OF THE CORE   *
* SUBROUTINES THAT THE WHOLE   *
* LIBRARY USES TO FUNCTION.    *
* MOST OF THESE ARE NOT USED   *
* BY THE PROGRAMMER, BUT ARE   *
* INTERNAL TO THE WORKINGS OF  *
* OTHER SUBROUTINES.           *
*                              *
* AUTHOR:    NATHAN RIGGS      *
* CONTACT:   NATHAN.RIGGS@     *
*            OUTLOOK.COM       *
*                              *
* DATE:      11-MAR-2021       *
* ASSEMBLER: MERLIN 8 PRO      *
* OS:        DOS 3.3           *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
** ASSEMBLER DIRECTIVES
*
         CYC   AVE
         EXP   OFF
         TR    ON
         DSK   DEMO.REQUIRED
         OBJ   $BFE0
         ORG   $6000
*
*``````````````````````````````*
*  TOP INCLUDES (HOOKS,MACROS) *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
         PUT   MIN.HEAD.REQUIRED.ASM
         USE   MIN.MAC.REQUIRED.ASM
*
]COUT    EQU   $FDF0
]HOME    EQU   $FC58
*
         JSR   ]HOME
*
*``````````````````````````````*
*      PROGRAM MAIN BODY       *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
*** SINCE THIS GROUP OF MACROS ARE PRIMARILY USED
*** INTERNALLY FOR THE LIBRARIES, DEMONSTRATIONS OF
*** THEIR USAGE WILL NOT BE GIVEN HERE. HOWEVER, A
*** QUICK LOOK AT ALMOST ANY LIBRARY'S MACRO FILE
*** WILL SHOW QUITE EASILY HOW THESE MACROS ARE USED.
*
* THE _AXLIT MACRO - .AX LITERAL
* THE _AXSTR MACRO - .AX STRING
* THE _ISLIT MACRO - IS LITERAL
* THE _ISSTR MACRO - IS STRING
* THE _MLIT MACRO  - MEMORY LITERAL
* THE _MSTR MACRO  - MEMORY STRING
*
*``````````````````````````````*
* _PRN, _WAIT AND BEEP         *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
*** THE _PRN, _WAIT AND BEEP MACROS ARE MOSTLY
*** AVAILABLE FOR DEBUGGING PURPOSES, AND ARE NOT
*** MEANT TO BE USED IN ACTUAL USER PROGRAMS
*** BEYOND THAT CAPACITY.
*
* THE _PRN MACRO   - PRINT
*
** THE _PRN MACRO SIMPLY PRINTS A LITERAL STRING
** TO THE SCREEN, AND HAS VERY LIMITED USE. WHEN
** OUTPUT IS MORE IMPORTANT THAN AN ERROR MESSAGE
** OR THE LIKE, USE THE MACROS PROVIDED BY THE
** STDIO LIBRARY.
*
** USAGE:
         JSR   ]HOME
         _PRN  "THE _PRN MACRO",8D
         _PRN  "===============",8D8D
**       _PRN  "THIS IS A TEST.",8D8D
*
         _PRN  "THIS IS A TEST.",8D8D
*
* THE _WAIT MACRO  - WAIT
*
** LIKEWISE, THE _WAIT MACRO IS FOR USES OF
** CONVENIENCE ONLY, AND THE STDIO LIBRARY
** SHOULD BE USED INSTEAD WHENEVER POSSIBLE.
** NONETHELESS, THE _WAIT MACRO SIMPLY WAITS
** FOR A KEYPRESS BEFORE EXECUTION CONTINUES.
*
** USAGE:
**       _WAIT
*
         _PRN  "THE WAIT MACRO",8D
         _PRN  "==============",8D8D
         _WAIT
*
* THE BEEP MACRO   - BEEP
*
** UNSURPRISINGLY, THE BEEP MACRO SENDS A STANDARD
** NUMBER OF TICKS TO THE SPEAKER TO PRODUCE A BEEP
** THAT CAN BE A LENGTH BETWEEN 1 AND 255.
*
** USAGE:
**       BEEP #255
*
         _PRN  "BEEEEEEEEEEEEEEP",8D8D
         BEEP  #255
*
*``````````````````````````````*
* LONG BRANCHING MACROS        *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
*** LONG BRANCHING ROUTINES ARE PRETTY SELF-
*** EXPLANATORY TO ANYONE WHO HAS RUN INTO THE
*** PAGE LENGTH PROBLEM WITH BRANCHING INSTRUCTIONS.
*** ESSENTIALLY, THESE MACROS TO THE APPROPRIATE TESTS,
*** THEN JMP TO THE PARAMETER ADDRESS PASSED. NOTE THAT
*** THIS CAN EASILY BREAK CODE THAT IS SUPPOSED TO BE
*** RELOCATABLE.
*
** SINCE ALL OF THE LONG BRANCHING MACROS WORK
** EXACTLY THE SAME, IT IS ONLY NECESSARY TO SHOW
** HOW ONE OF THEM IS USED. WE WILL USE BCCL HERE,
** OR BRANCH CARRY CLEAR LONG.
*
** USAGE:
**       CLC
**       BCCL  ]CONTINUE
**       BRK
** ]CONTINUE
**       _PRN "THE CARRY IS CLEAR.",8D8D
         _WAIT
*
         _PRN  "THE BCCL MACRO",8D
         _PRN  "==============",8D8D
         CLC
         BCCL  ]CONTINUE
         BRK
]CONTINUE
         _PRN  "THE CARRY IS CLEAR.",8D8D
         _WAIT
*
* THE BCCL MACRO   - BRANCH CARRY CLEAR LONG
* THE BCSL MACRO   - BRANCH CARRY SET LONG
* THE BEQL MACRO   - BRANCH IF EQUAL LONG
* THE BMIL MACRO   - BRANCH IF MINUS LONG
* THE BNEL MACRO   - BRANCH NOT EQUAL LONG
* THE BPLL MACRO   - BRANCH IF PLUS LONG
* THE BVCL MACRO   - BRANCH OVERFLOW CLEAR LONG
* THE BVSL MACRO   - BRANCH OVERFLOW SET LONG
*
*``````````````````````````````*
* FAKE 65CO2 MACROS            *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
*** THE FAKE 65C02 MACROS ARE APROXIMATIONS
*** OF THE RELEVANT INSTRUCTIONS IN THE 65C02
*** INSTRUCTION SET WHEN YOU ONLY HAVE A 6502
*** TO WORK WITH. OBVIOUSLY, IF A 65C02 PROCESSOR
*** IS READILY AVAILABLE, YOU SHOULD USE THE
*** REAL INSTRUCTION SET.
*
* THE CBRA MACRO   - 65C02 BRANCH ALWAYS
*
** THE CBRA MACRO SIMPLY REPLACES THE MACRO WITH
** A JMP INSTRUCTION TO EMULATE THE BRANCH ALWAYS (BRA)
** 65CO2 INSTRUCTION. IT WORKS LIKE YOU'D EXPECT:
*
** USAGE:
*
**       CBRA  ]CONT
**       BRK
**]CONT  _PRN  "CBRA WORKED AS EXPECTED.",8D8D
**       _WAIT
*
         _PRN  "THE CBRA MACRO",8D
         _PRN  "==============",8D8D
         CBRA  ]CONT
         BRK
]CONT    _PRN  "CBRA WORKED AS EXPECTED.",8D8D
         _WAIT
*
* THE CPHX MACRO   - 65C02 PUSH .X
*
** THE CPHX MACRO EMULATES THE 65C02 INSTRUCTION
** THAT PUSHES .X TO THE STACK.
*
** USAGE:
*
**       LDX   #$FF
**       CPHX
**       _PRN  "CONTENT PULLED FROM STACK: "
**       PLA           ; .X IS NOW IN .A
**       STA   $300
**       DUMP  #$300;#1
**       _PRN  " ",8D8D
**       _WAIT
*
         _PRN  "THE CPHX MACRO",8D
         _PRN  "==============",8D8D
         LDX   #$FF
         CPHX
         _PRN  "CONTENT PULLED FROM THE STACK: "
         PLA
         STA   $300
         DUMP  #$300;#1
         _PRN  " ",8D8D
         _WAIT
*
* THE CPHY MACRO   - 65C02 PUSH .Y
*
** THE CPHY MACRO WORKS THE SAME WAY AS THE CPHX
** MACRO, EXCEPT PUSHES .Y INSTEAD OF .X. THUS,
** IT WOULD BE REDUNDANT TO SHOW THE EXACT SAME PROCESS--
** TREAT THE MACRO THE SAME WAY.
*
* THE CPLX MACRO   - 65C02 PULL .X
*
** THE CPLX MACRO EMULATES THE PLX INSTRUCTION
** FOR THE 65C02. THE VALUE AT THE TOP OF THE STACK
** IS PULLED AND THEN STORED IN .X.
*
** USAGE:
**       LDA   #$EE
**       PHA
**       CPLX
**       STX   $300
**       _PRN  "VALUE PULLED FROM STACK:"
**       DUMP  #$300;#1
**       _WAIT
**       _PRN  " ",8D8D
*
         _PRN  "THE CPLX MACRO",8D
         _PRN  "==============",8D8D
         LDA   #$EE
         PHA
         CPLX
         STX   $300
         _PRN  "VALUE PULLED FROM STACK:"
         DUMP  #$300;#1
         _WAIT
         _PRN  " ",8D8D
*
* THE CPLY MACRO   - 65C02 PULL .Y
*
** THE CPLY MACRO, OR 65CO2 PULL .Y MACRO,
** EMULATES THE 65C02 INSTRUCTION PLY. AGAIN,
** THIS WORKS EXACTLY THE SAME AS CPLX, EXCEPT
** THE PULL IS STORED IN .Y INSTEAD OF .X.
** THEREFORE, WE NEED NOT BE REDUNDANT.
*
* THE CTXY MACRO   - 65C02 TRANSFER .X TO .Y
*
** THE CTXY MACRO EMULATES THE 65C02 TRANSFER .X TO .Y
** INSTRUCTION, TXY. .A IS USED AS AN INTERMEDIARY, AND
** THEN ITS ORIGINAL VALUE IS RESTORED.
*
** USAGE:
**       LDY   #0
**       LDX   #$DD
**       CTXY
**       STY   $300
**       _PRN "CONTENT IN .Y:"
**       DUMP  #$300;#1
**       _WAIT
**       _PRN  " ",8D8D
*
         _PRN  "THE CTXY MACRO",8D
         _PRN  "==============",8D8D
         LDY   #0
         LDX   #$DD
         CTXY
         STY   $300
         _PRN  "CONTENT IN .Y:"
         DUMP  #$300;#1
         _WAIT
         _PRN  " ",8D8D
*
* THE CTYX MACRO   - 65C02 TRANSFER .Y TO .X
*
** LIKE MANY SUBROUTINES BEFORE, THE CTYX MACRO OR
** THE TRANSFER .Y TO .X MACRO, WORKS EXACTLY LIKE
** ITS RELATED SUBROUTINE, THE CTXY MACRO, AND THUS
** ITS USAGE SHOULD BE REFERRED TO IN THAT EXAMLPLE.
** THIS MACRO EMULATES THE CYX INSTRUCTION IN 65CO2.
*
*``````````````````````````````*
* MEMORY MANIPULATION MACROS   *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
*** THE MACROS DEDICATED TO MANIPULATING MEMORY
*** ARE USED FOR A VARIETY OF REASONS, BUT IF
*** YOU ARE A SEASONED PROGRAMMER, YOU ALREADY KNOW
*** THAT 99.9% OF THE JOB IS MEMORY MANIPULATION.
*** THESE HERE ENCOMPASS THOSE DEDICATED TO MOVING,
*** COPYING, AND FILLING MEMORY BLOCKS, AS WELL AS
*** VIEWING MEMORY CONTENTS FOR DEBUGGING PURPOSES.
*** FOR FUN, A POKE AND PEEK MACRO ARE INCLUDED FOR
*** THE APPLESOFT KIDS, AND LOADS OR PULLS THE VALUE INTO .A.
*
* THE DUMP MACRO   - MEMORY DUMP
*
** THE DUMP MACRO HAS ACTUALLY ALREADY BEEN
** USED TO SHOW THE CONTENTS RETURNED BY SOME
** OF THE 65C02 EMULATION MACROS. THE MACRO
** SIMPLY DUMPS A BLOCK OF MEMORY SPECIFIED BY
** THE PARAMETERS PASSED. THEREFORE:
*
** USAGE:
*
**       LDA   #$BB
**       STA   $300
**       LDA   #$AA
**       STA   $301
**      _PRN   "VALUES IN $301-$302:"
**       DUMP  #$300;#2
**       _WAIT
**       _PRN " ",8D8D
*
         _PRN  "THE DUMP MACRO",8D
         _PRN  "==============",8D8D
         LDA   #$BB
         STA   $300
         LDA   #$AA
         STA   $301
         _PRN  "VALUES IN $301-$302:"
         DUMP  #$300;#2
         _WAIT
         _PRN  " ",8D8D
*
* THE ERRH MACRO   - ERROR HANDLER
*
** THE ERRH MACRO SETS THE ERROR HANDLING
** HOOK FOR SOUBROUTINES THAT RELY ON
** APPLESOFT IN SOME WAY. THIS IS PARTICULARLY
** USED TO DETECT AN END-OF-FILE WHEN
** READING A TEXT FILE, AS THERE IS NO "STANDARD"
** WAY TO DETECT THE EOF EXCEPT BY THE ERROR RETURN.
*
** USAGE:
**       ERRH  #$6000
*
** SINCE THIS ROUTINE REQUIRES TOO MUCH INTEGRATION
** WITH OTHER LIBRARIES, YOU WON'T BE SEEING A
** DEMO HERE. HOWEVER, THE CURRENT ITERATION OF THE
** FILEIO LIBRARY MAKES EXTENSIVE USE OF THE MACRO,
** AND CAN BE REFERRED TO FOR PLENTLY OF EXAMPLES.
*
* THE GRET MACRO   - GET RETURN
*
** THE GRET MACRO STANDS FOR "GET RETURN," AND
** SIMPLY COPIES THE CONTENTS OF THE RETURN
** MEMORY BLOCK TO ANOTHER MEMORY BLOCK. THE
** LENGTH OF THIS BLOCK IS DETERMINED BY THE
** RETLEN VARIABLE, WHICH LOGICALLY PRECEDES THE
** RETURN BLOCK AS A BYTE. AS SUCH, NOTE THAT
** RETURN CAN ONLY HOLD UP TO 255 BYTES, AND
** THUS THIS IS THE MAXIMUM TO BE TRANSFERRED.
*
** USAGE:
*
**       LDA   #$11
**       STA   RETURN
**       LDA   #$12
**       STA   RETURN+1
**       LDA   #$13
**       STA   RETURN+2
**       LDA   #3
**       STA   RETLEN
**       GRET  #$300
**       _PRN  "THE 3 BYTES PUT IN RETURN ARE NOW AT $300:"
**       DUMP  #$300;#3
**       _WAIT
**       _"PRN  " ",8D8D
         _PRN  "THE GRET MACRO",8D
         _PRN  "==============",8D8D
         LDA   #$11
         STA   RETURN
         LDA   #$12
         STA   RETURN+1
         LDA   #$13
         STA   RETURN+2
         LDA   #3
         STA   RETLEN
         GRET  #$300
         _PRN  "THE 4 BYTES PUT IN RETURN ARE NOW AT $300"
         DUMP  #$300;#3
         _WAIT
         _PRN  " ",8D8D
*
* THE MFILL MACRO  - MEMORY FILL
*
** THE MFILL MACRO FILLS A BLOCK OF MEMORY
** FROM A GIVEN STARTING ADDRESS AND A LENGTH
** IN BYTES WITH THE SPECIFIED FILL VALUE.
** NOTE THAT OVERFLOW ISSUES ARE TAKEN INTO
** CONSIDERATION, AND THAT DETERMINES HOW THE
** MEMORY LOCATIONS ARE READ AND FILLED (BACKWARDS
** OR FORWARDS).
*
** USAGE:
*
**       MFILL #$300;#$08;#$FF
**        _PRN  "$300-$308 = "
**        DUMP  #$300;#$08
**       _WAIT
**       _PRN  " ",8D8D
*
         _PRN  "THE MFILL MACRO",8D
         _PRN  "===============",8D8D
         MFILL #$300;#$08;#$FF
         _PRN  "$300-$308 =",8D8D
         DUMP  #$300;#$08
         _WAIT
         _PRN  " ",8D8D
*
* THE MOVB MACRO   - MOVE MEMORY BLOCKS
*
** THE MOVB MACRO, WHICH STANDS FOR MOVE
** BLOCK, DOES EXACTLY WHAT IT SAYS: IT MOVES
** A BLOCK OF MEMORY TO ANOTHER BLOCK OF
** MEMORY, THOUGH THIS SHUOLD BE SEEN MORE AS
** A COPY, SINCE THE ORIGINAL DATA IS STILL
** IN PLACE AFTER CALLING THE MACRO. NOTE THAT
** NO CHECKS FOR OVERLAP ARE MADE, SO ERROR
** CONTROL IS IN THAT RESPECT IS LEFT UP TO
** THE END PROGRAMMER.
*
** USAGE:
*
**       LDA   #$AA
**       STA   $300
**       LDA   #$BB
**       STA   $301
**       LDA   #$CC
**       STA   $302
**       MOVB  #$300;#$310;#3
**       _PRN  "$310-$312 NOW = $300-$302"
**       DUMP  #$310;#3
**       _WAIT
**       _PRN  " ",8D8D
*
         _PRN  "THE MOVB MACRO",8D
         _PRN  "==============",8D8D
         LDA   #$AA
         STA   $300
         LDA   #$BB
         STA   $301
         LDA   #$CC
         STA   $302
         MOVB  #$300;#$310;#3
         _PRN  "$310-$312 NOW = $300-$302"
         DUMP  #$310;#3
         _WAIT
         _PRN  " ",8D8D
*
* THE MSWAP MACRO  - SWAP MEMORY BLOCKS
*
** THE MSWAP MACRO SWAPS THE VALUES HELD IN TWO
** BLOCKS OF MEMORY. NOTE THAT NO OVERFLOW CHECKING
** IS DONE, SO THE END PROGRAMMER HAS TO BE CAREFUL
** WHEN USING THE MACRO.
*
** USAGE:
*
**       LDA   #$66
**       STA   $300
**       LDA   #$77
**       STA   $301
**       LDA   #$88
**       STA   $302
**       MSWAP #$300;#$310;#4
**       DUMP  #$300;#3
**       DUMP  #$310;#3
**       _PRN  " ",8D8D
**       _PRN   "$300-$302 HAS BEEN SWAPPED WITH $310-$312",8D8D
**       _WAIT
*
         _PRN  "THE MSWAP MACRO",8D
         _PRN  "===============",8D8D
         LDA   #$66
         STA   $300
         LDA   #$77
         STA   $301
         LDA   #$88
         STA   $302
         MSWAP #$300;#$310;#4
         DUMP  #$300;#3
         DUMP  #$310;#3
         _PRN  " ",8D8D
         _PRN  "$300-$302 WAS SWAPPED WITH $310-312.",8D8D
         _WAIT
*
* THE PEEK MACRO   - PEEK MEMORY
*
** THE PEEK MACRO EMULATES THE PEEK INSTRUCTION
** IN APPLESOFT, KINDA. MOSTLY, IT JUST LOADS
** A VELUE FROM MEMORY INTO .A. HOWEVER, MORE
** FUNCTIONALITY MAY BE ADDED TO THIS MACRO IN
** THE FUTURE IN ORDER TO DIFFERENTIATE IT FROM
** SIMPLY LDA ##.
*
** USAGE:
*
**       LDA   #$EE
**       STA   $300
**       PEEK  #$300
**       STA   RETURN
**       _PRN  ".A  NOW HOLDS:",8D8D
**       DUMP  #RETURN;#1
**       _PRN  " ",8D8D
**       _WAIT
*
         _PRN  "THE PEEK MACRO",8D
         _PRN  "==============",8D8D
         LDA   #$EE
         STA   $300
         PEEK  #$300
         STA   RETURN
         _PRN  ".A NOW HOLDS:",8D8D
         DUMP  #RETURN;#1
         _PRN  " ",8D8D
         _WAIT
*
* THE POKE MACRO   - POKE MEMORY
*
** LIKE THE PEEK MACRO, THE POKE MACRO SIMPLY
** BEHAVES LIKE THE APPLESOFT EQUIVALENT, PUTTING
** THE FIRST PARAMETER VALUE INTO THE SECOND PARAMETER'S
** ADDRESSS. LIKE WITH PEEK, MORE MAY BE ADDED TO THE
** MACRO'S FUNCTIONALITY IN THE FUTURE.
*
** USAGE:
*
**       POKE   #$99;#$300
**       _PRN  "$300 CONTAINS:"
**       DUMP  #$300;#1
**       _PRN  " ",8D8D
**       _WAIT
*
         _PRN  "THE POKE MACRO",8D
         _PRN  "==============",8D8D
         POKE  #$99;#$300
         _PRN  "$300 CONTAINS:"
         DUMP  #$300;#1
         _PRN  " ",8D8D
         _WAIT
*
*``````````````````````````````*
* THE WEIRDOS: CLRHI,DELAY AND *
* GBIT MACROS.                 *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
*** THESE MACROS CAN BE HIGHLY USEFUL,
*** BUT SO FAR DO NOT FIT WELL WITH ANY
*** OTHER GROUPING OF MACROS.
*
* THE CLRHI MACRO  - CLEAR HIGH NIBBLE
*
** THE CLRHI MACRO CLEARS THE HIGH NIBBLE IN .A
** BYTE TO %0000. THIS HAS VARIOUS USES THAT NEED
** NOT BE GONE OVER HERE.
*
** USAGE:
*
**       LDA   #$FF
**       CLRHI
**       STA   $300
**       DUMP  #$300;#1
**       _PRN  "^^ THE HIGH NIBBLE WAS CLEARED"
**       _PRN  " ",8D8D
**       _WAIT
*
         _PRN  "THE CLRHI MACRO",8D
         _PRN  "===============",8D8D
         LDA   #$FF
         CLRHI
         STA   $300
         DUMP  #$300;#1
         _PRN  "^^ THE HIGH NIBBLE WAS CLEARED"
         _PRN  " ",8D8D
         _WAIT
*
* THE DELAY MACRO  - DELAY
*
** THE DELAY MACRO SIMPLY DELAYS RXECUTION
** FOR A NUMBER OF MILLISECONDS. THIS ACCEPTS
** A BYTE VALUE, SO IF YOU WANT A SINGLE SECOND
** OF DELAY, YOU NEED TO RUN THE MACRO FOR TIMES
** AS SUCH:
*
** USAGE:
*
**       DELAY #250
**       DELAY #250
**       DELAY #250
**       DELAY #250
**       _PRN  "DONE!",8D8D
**       _WAIT
*
         _PRN  "THE DELAY MACRO",8D
         _PRN  "===============",8D8D
         DELAY #250
         DELAY #250
         DELAY #250
         DELAY #250
         _PRN  "DONE!",8D8D
         _WAIT
*
* THE GBIT MACRO   - GET BIT VALUE
*
** THE GBIT MACRO RETURNS THE BIT VALUE
** OF THE GIVEN POSITION IN THE PARAMETER.
*
** USAGE:
*
**       GBIT  #0;#%00100101
**       STA   $300
**       DUMP  #$300;#1
**       _WAIT
*
         _PRN  "THE GBIT MACRO",8D
         _PRN  "==============",8D8D
         GBIT  #0;%00100101
         STA   $300
         DUMP  #$300;#1
         _WAIT
*
         JSR   ]HOME
*
*``````````````````````````````*
* 8080 ALIAS MACROS            *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
*** THE 8080 ALIAS MACROS ARE APPROXIMATIONS
*** OF SOME OF THE INSTRUCTIONS IN THE 8080
*** INSTRUCTION SET, FOR USE BY THOSE WHO ARE
*** USED TO PROGRAMMING IN 8080 ASSEMBLY. NOTE
*** AGAIN THE WORD **APPROXIMATION**, AS I AM
*** NOT AN 8080 PROGRAMMER.
*
*** ALSO NOTE THAT YOU CAN ONLY USE ONE SET OF
*** ALIAS FILES AT A TIME; OTHERWISE, MACROS
*** WITH THE SAME NAME IN EACH ALIAS FILE WILL
*** CAUSE AN ASSEMBLY ERROR. THIS IS MOST NOTABLE
*** WITH INSTRUCTIONS LIKE 'RET' OR 'CALL."
*
*** SINCE ALL OF THESE MACROS ARE FAIRLY SIMPLE,
*** EXAMPLES ARE NOT GIVEN HERE. A FEW MACROS MAY
*** NEED EXAMPLES IN THE FUTURE, BUT THESE MOSTLY
*** WORK THE WAY YOU MIGHT EXPECT.
*
*
* CALL  - MIMICS JSR INSTRUCTION
* RET   - MIMICS RTS INSTRUCTION
* JA    - JMP IF .A > CMP RESULT
* JAE   - JMP IF .A => CMP RESULT
* JB    - JMP IF .A < CMP RESULT
* JBE   - JMP IF .A =< CMP RESULT
* JC    - JMP IF C = 1
* JE    - JMP IF BEQ
* JG    - JMP IF .A > CMP RESULT
* JGE   - JMP IF .A >= CMP RESULT
* JL    - JMP IF .A < CMP RESULT
* JLE   - JMP IF .A <= CMP RESULT
* JNC   - JMP IF C = 0
* JZ    - JMP IF Z = 0
* JNZ   - JMP IF Z = 1
* JS    - JMP IF SIGNED
* JNS   - JMP IF NOT SIGNED
* JO    - JMP IF V = 1
* JNO   - JMP IF V = 0
* ANC   - ADD NO CARRY
* SNC   - SUBTRACT NO CARRY
* PUSHA - PUSH ALL REGISTERS
* PULLA - PULL ALL REGISTERS
* POPA  - PULL ALL REGISTERS
*
*``````````````````````````````*
* Z80 ALIAS MACROS             *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
*** THESE MACROS ARE APPROXIMATIONS OF
*** SOME INSTRUCTIONS IN THE Z80 SET, AND
*** ARE MEANT TO AID THE PROGRAMMER WHO IS
*** USED TO A Z80 CPU. CURRENTLY, ALL OF THESE
*** EXAMPLES ARE COMMENTED OUT DUE TO THE FACT
*** THAT SOME OF THE MACRO NAMES CONFLICT WITH
*** THE 8080 ALIAS SET. TO SEE THESE IN ACTION,
*** YOU MUST FIRST COMMENT OUT THE 8080 EXAMPLES
*** AND THEN COMMENT OUT THE 8080 ALIAS FILE
*** INCLUDE AT THE END, WHILE ALSO UNCOMMENTING
*** THE Z80 ALIAS FILE INCLUSION.
*
* CALL  - JSR EQUIVALENT
* CPL   - INVERTS BITS IN .A
* JP    - JMP EQUIVALENT
* LD    - MOV VALUE FROM SRC TO DEST
* POP   - PULL FROM STACK
* RET   - RTS EQUIVALENT
* SCF   - C = 1
*
         JMP   REENTRY
*
*``````````````````````````````*
*        BOTTOM INCLUDES       *
*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*
*
** BOTTOM INCLUDES
*
         PUT   MIN.LIB.REQUIRED.ASM
         USE   MIN.MAC.ALIAS.8080.ASM
*USE MIN.MAC.ALIAS.Z80.ASM
*
